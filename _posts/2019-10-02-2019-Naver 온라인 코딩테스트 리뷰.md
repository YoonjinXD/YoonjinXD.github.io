---
layout: post
title: 2019 Naver 온라인 코딩테스트 리뷰
categories: Etc
tags: Etc
---

2020년 신입 개발자 채용을 위한 온라인 코딩테스트가 2019년 9월 22일 일요일에 치뤄졌습니다. 지난주쯤 카카오 1차 온라인 코딩테스트를 보고, 바로 전날인 21일 카카오 2차 오프라인 코딩테스트까지 치룬 후 보았기 때문인지 개인적으로는 비교적 쉬웠던 것 같습니다. ~~카카오 2차에 비하면…ㅜ~~문제는 총 3문제였습니다.

테스트는 프로그래머스에서 진행되었고, 저는 모두 파이썬으로 풀었습니다. 기억 나는 것만 짧게 리뷰해보겠습니다.



* 1번 문제
  * 문제: 임시 메일 보관함을 구현하는 문제로, 메일 송수신 및 사용자의 명령 레코드가 인풋으로 주어졌고 이 레코드대로 진행된 결과를 출력해야 한다. RECEIVE 레코드는 임시 보관함에 수신된 메일들을 저장하고, SAVE는 현재 임시보관함에 있는 메일 전부를 일반메일함에 옮겨 저장한다. REMOVE는 임시 보관함에 가장 최근 수신된 메일을 삭제한다.
  * 풀이: 문제를 읽는 순간부터 이건 무조건 스택이다! 라는 생각이 들 수 밖에 없었다. 임시 보관함과 일반 메일함 두개의 리스트를 생성한 후 레코드를 파싱하여 문제에 명시된 그대로 액션을 구현했다. 테스트 케이스 통과를 받는데 10분정도가 걸렸다. 너무 쉬워서 오히려 당황스러웠다. 이건 솔직히 다른 사람들도 다 쉽게 풀었을거다.

---

* 2번 문제
  * 문제: 연속된 2개 이상의 숫자들을 더하여 나올 수 있는 모든 숫자를 오름차순으로 정리한 수열이 주어졌다. 이 수열에서 N번째 수를 출력한다. N은 10 ~ 100,000개?(기억이 가물가물) 까지 가능하다
  * 풀이: 문제 자체는 간단한데… 난해했다. 처음에 문제를 잘못 읽어서 연속된 '2개' 숫자를 더하라는 건 줄 알고 너무 쉽다고 생각하고 있었다. 그런데 2개 이상이라 하니, 그 때부터 머리가 아파지기 시작했다. 어느 지점에서 더하느냐에 따라 5개의 연속된 숫자를 더해도 3개의 연속된 숫자를 더한 것보다 수가 작을 수 있었고, 서로 다른 지점에서 연속되는 숫자들이더라도 더하는 개수에 따라 그 값이 같아질 수도 있었다. 입력으로 들어오는 N의 범위가 컸기 때문에, 모든 경우의 수를 다 계산하여 저장한 후 정렬하면 시간복잡도가 터질 게 분명했다. 분명 무언가 알고리즘을 응용하는 걸텐데… 라는 생각을 하며 한시간을 삽질했지만 아이디어가 도무지 떠오르지 않았다. 결국 그냥 위의 방법대로 모든 걸 계산한 후 정렬하는 방법으로 코드를 제출했다. 아마 분명 터졌을 것이다. 허허.
  * (+) 지금 생각해보니 M개의 연속된 숫자를 더하기 위한 길이 M짜리 윈도우를 쭉 이동시키고, M을 하나씩 줄여가며 비교해가는 건 어땠을까 싶다.

---

* 3번 문제

  * 문제: 로이네 집에서 송편을 만드는 문제ㅋㅋ 송편을 만들기 위해서는 6개였나 7개의 단계가 필요하다.(솔잎 씻기, 반죽하기, 고명 만들기, 송편 빗기, 찌기 등등…) 모든 단계들은 각각의 소요 시간을 가지고 있고, 선수 관계 역시 가지고 있다. 예를 들어 '송편 빗기' 단계를 실행하기 위해서는 그 이전 단계인 '반죽하기', '고명 만들기' 등이 먼저 완료되어야 하고, '찌기' 단계를 실행하기 전에  '솔잎 씻기' 단계가 먼저 수행되어야 한다. 단, 서로 선수 관계에 놓여있지 않는 두 작업은 동시에 이루어질 수 있다. (ex. 솔잎을 씻는 동시에 그와 관계 없는 반죽 하기는 할 수 있다.) 로이네 집은 송편 말고도 다양한 음식을 만들 것이다. 입력으로는 어떤 음식을 만들기 위한 각 단계들의 소요시간과 선수 관계가 들어온다. 이때 특정 단계까지의 최소 소요 시간과 그 단계가 실행되기까지 필요한 모든 단계의 개수를 구해라. - 로이네 집에는 동시에 여러개의 작업을 할 수 있을만큼 사람이 많다고 가정한다.(즉 제한이 없단 소리)

  * 풀이: 각 단계별 선수 관계를 보고 트리를 구성하기로 했다. 하나의 단계를 하나의 노드로 둔 후, 자식 노드에는 현재 이 단계가 실행되기 위해 우선 수행되어야 하는 단계들을, 부모 노드에는 똑같이 나를 우선 수행해야 하는 단계를 둔다. 자연스레 최상위 루트 노드는 마지막 단계(접시에 담기와 같은)가 되고, 가장 하위 리프 노드들은 전단계가 없는 첫단계들로 이루어지게 된다. 소요시간은 각 노드들의 값으로 주었다. 특정 단계까지의 최소 소요시간은 자식 노드 중의 최대 시간으로 구하는데, 계층 구조이므로 재귀를 사용했다. 만약 4 단계가 실행되기 위해 1, 2, 3 단계가 필요하다면, 어차피 이 세 단계 중 가장 시간이 오래 걸리는 놈이 4단계까지의 최소 소요 시간이다. 계층이 더 깊어지더라도 한 계층 올라갈 때 내 소요 시간을 더한 후 반환하기만 하면 되니까 - 재귀로 풀면 된다. 특정 단계까지 필요한 단계의 개수 역시 재귀로 거의 비슷하게 풀었다. 
    이 문제는 내 코드를 캡쳐해놓았다.

    ![img]({{site.url}}/public/images/2019_naver_ct_1.png)
    ![img]({{site.url}}/public/images/2019_naver_ct_2.png)



네이버 코딩테스트는 각 문제 별 난이도 차가 심했던 것 같다. 1번 3번은 빠르게 풀긴 했지만, 2번을 보니 혹시 내가 발견하지 못한 함정은 없었을까 불안하다. 테스트 케이스도 아주 간단한 3~4개 정도밖에 주지 않아서, 혹시나 생각지 못한 부분이 있지는 않을까.. 또 불안하다… 흑흑. 

그래도 재밌긴했다! 결과가 잘 나왔으며언

(+) ㅅㅔ상에 합격! 이제 1차 면접 준비를 8ㅅ8